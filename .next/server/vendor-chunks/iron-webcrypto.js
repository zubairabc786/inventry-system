"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-webcrypto";
exports.ids = ["vendor-chunks/iron-webcrypto"];
exports.modules = {

/***/ "(action-browser)/./node_modules/iron-webcrypto/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/iron-webcrypto/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// src/utils.ts\nvar alphabetByEncoding = {};\nvar alphabetByValue = Array.from({\n    length: 64\n});\nfor(let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor(let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    const index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor(let i = 0; i < 10; i++){\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    const char = i.toString(10);\n    const index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"-\"] = 62;\nalphabetByValue[62] = \"-\";\nalphabetByEncoding[\"_\"] = 63;\nalphabetByValue[63] = \"_\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nvar stringToBuffer = (value)=>{\n    return new TextEncoder().encode(value);\n};\nvar bufferToString = (value)=>{\n    return new TextDecoder().decode(value);\n};\nvar base64urlDecode = (_input)=>{\n    const input = _input + \"=\".repeat((4 - _input.length % 4) % 4);\n    let totalByteLength = input.length / 4 * 3;\n    if (input.endsWith(\"==\")) {\n        totalByteLength -= 2;\n    } else if (input.endsWith(\"=\")) {\n        totalByteLength--;\n    }\n    const out = new ArrayBuffer(totalByteLength);\n    const dataView = new DataView(out);\n    for(let i = 0; i < input.length; i += 4){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = i + 3; j <= limit; j++){\n            if (input[j] === \"=\") {\n                bits >>= bitsPerLetter;\n            } else {\n                if (!(input[j] in alphabetByEncoding)) {\n                    throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n                }\n                bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n                bitLength += bitsPerLetter;\n            }\n        }\n        const chunkOffset = i / 4 * 3;\n        bits >>= bitLength % bitsPerByte;\n        const byteLength = Math.floor(bitLength / bitsPerByte);\n        for(let k = 0; k < byteLength; k++){\n            const offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n};\nvar base64urlEncode = (_input)=>{\n    const input = typeof _input === \"string\" ? stringToBuffer(_input) : _input;\n    let str = \"\";\n    for(let i = 0; i < input.length; i += 3){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = Math.min(i + 3, input.length); j < limit; j++){\n            bits |= input[j] << (limit - j - 1) * bitsPerByte;\n            bitLength += bitsPerByte;\n        }\n        const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for(let k = 1; k <= bitClusterCount; k++){\n            const offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n        }\n    }\n    return str;\n};\n// src/index.ts\nvar defaults = {\n    encryption: {\n        saltBits: 256,\n        algorithm: \"aes-256-cbc\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    integrity: {\n        saltBits: 256,\n        algorithm: \"sha256\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    ttl: 0,\n    timestampSkewSec: 60,\n    localtimeOffsetMsec: 0\n};\nvar clone = (options)=>({\n        ...options,\n        encryption: {\n            ...options.encryption\n        },\n        integrity: {\n            ...options.integrity\n        }\n    });\nvar algorithms = {\n    \"aes-128-ctr\": {\n        keyBits: 128,\n        ivBits: 128,\n        name: \"AES-CTR\"\n    },\n    \"aes-256-cbc\": {\n        keyBits: 256,\n        ivBits: 128,\n        name: \"AES-CBC\"\n    },\n    sha256: {\n        keyBits: 256,\n        name: \"SHA-256\"\n    }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = \"Fe26.2\";\nvar randomBytes = (_crypto, size)=>{\n    const bytes = new Uint8Array(size);\n    _crypto.getRandomValues(bytes);\n    return bytes;\n};\nvar randomBits = (_crypto, bits)=>{\n    if (bits < 1) throw new Error(\"Invalid random bits count\");\n    const bytes = Math.ceil(bits / 8);\n    return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash)=>{\n    const passwordBuffer = stringToBuffer(password);\n    const importedKey = await _crypto.subtle.importKey(\"raw\", passwordBuffer, {\n        name: \"PBKDF2\"\n    }, false, [\n        \"deriveBits\"\n    ]);\n    const saltBuffer = stringToBuffer(salt);\n    const params = {\n        name: \"PBKDF2\",\n        hash,\n        salt: saltBuffer,\n        iterations\n    };\n    const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n    return derivation;\n};\nvar generateKey = async (_crypto, password, options)=>{\n    var _a;\n    if (!(password == null ? void 0 : password.length)) throw new Error(\"Empty password\");\n    if (options == null || typeof options !== \"object\") throw new Error(\"Bad options\");\n    if (!(options.algorithm in algorithms)) throw new Error(`Unknown algorithm: ${options.algorithm}`);\n    const algorithm = algorithms[options.algorithm];\n    const result = {};\n    const hmac = (_a = options.hmac) != null ? _a : false;\n    const id = hmac ? {\n        name: \"HMAC\",\n        hash: algorithm.name\n    } : {\n        name: algorithm.name\n    };\n    const usage = hmac ? [\n        \"sign\",\n        \"verify\"\n    ] : [\n        \"encrypt\",\n        \"decrypt\"\n    ];\n    if (typeof password === \"string\") {\n        if (password.length < options.minPasswordlength) throw new Error(`Password string too short (min ${options.minPasswordlength} characters required)`);\n        let { salt = \"\" } = options;\n        if (!salt) {\n            const { saltBits = 0 } = options;\n            if (!saltBits) throw new Error(\"Missing salt and saltBits options\");\n            const randomSalt = randomBits(_crypto, saltBits);\n            salt = [\n                ...new Uint8Array(randomSalt)\n            ].map((x)=>x.toString(16).padStart(2, \"0\")).join(\"\");\n        }\n        const derivedKey = await pbkdf2(_crypto, password, salt, options.iterations, algorithm.keyBits / 8, \"SHA-1\");\n        const importedEncryptionKey = await _crypto.subtle.importKey(\"raw\", derivedKey, id, false, usage);\n        result.key = importedEncryptionKey;\n        result.salt = salt;\n    } else {\n        if (password.length < algorithm.keyBits / 8) throw new Error(\"Key buffer (password) too small\");\n        result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n        result.salt = \"\";\n    }\n    if (options.iv) result.iv = options.iv;\n    else if (\"ivBits\" in algorithm) result.iv = randomBits(_crypto, algorithm.ivBits);\n    return result;\n};\nvar getEncryptParams = (algorithm, key, data)=>{\n    return [\n        algorithm === \"aes-128-ctr\" ? {\n            name: \"AES-CTR\",\n            counter: key.iv,\n            length: 128\n        } : {\n            name: \"AES-CBC\",\n            iv: key.iv\n        },\n        key.key,\n        typeof data === \"string\" ? stringToBuffer(data) : data\n    ];\n};\nvar encrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const encrypted = await _crypto.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));\n    return {\n        encrypted: new Uint8Array(encrypted),\n        key\n    };\n};\nvar decrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const decrypted = await _crypto.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));\n    return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, {\n        ...options,\n        hmac: true\n    });\n    const textBuffer = stringToBuffer(data);\n    const signed = await _crypto.subtle.sign({\n        name: \"HMAC\"\n    }, key.key, textBuffer);\n    const digest = base64urlEncode(new Uint8Array(signed));\n    return {\n        digest,\n        salt: key.salt\n    };\n};\nvar normalizePassword = (password)=>{\n    if (typeof password === \"string\" || password instanceof Uint8Array) return {\n        encryption: password,\n        integrity: password\n    };\n    if (\"secret\" in password) return {\n        id: password.id,\n        encryption: password.secret,\n        integrity: password.secret\n    };\n    return {\n        id: password.id,\n        encryption: password.encryption,\n        integrity: password.integrity\n    };\n};\nvar seal = async (_crypto, object, password, options)=>{\n    if (!password) throw new Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const objectString = JSON.stringify(object);\n    const pass = normalizePassword(password);\n    const { id = \"\", encryption, integrity } = pass;\n    if (id && !/^\\w+$/.test(id)) throw new Error(\"Invalid password id\");\n    const { encrypted, key } = await encrypt(_crypto, encryption, opts.encryption, objectString);\n    const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n    const iv = base64urlEncode(key.iv);\n    const expiration = opts.ttl ? now + opts.ttl : \"\";\n    const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n    const mac = await hmacWithPassword(_crypto, integrity, opts.integrity, macBaseString);\n    const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n    return sealed;\n};\nvar fixedTimeComparison = (a, b)=>{\n    let mismatch = a.length === b.length ? 0 : 1;\n    if (mismatch) b = a;\n    for(let i = 0; i < a.length; i += 1)mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options)=>{\n    if (!password) throw new Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const parts = sealed.split(\"*\");\n    if (parts.length !== 8) throw new Error(\"Incorrect number of sealed components\");\n    const prefix = parts[0];\n    let passwordId = parts[1];\n    const encryptionSalt = parts[2];\n    const encryptionIv = parts[3];\n    const encryptedB64 = parts[4];\n    const expiration = parts[5];\n    const hmacSalt = parts[6];\n    const hmac = parts[7];\n    const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n    if (macPrefix !== prefix) throw new Error(\"Wrong mac prefix\");\n    if (expiration) {\n        if (!/^\\d+$/.test(expiration)) throw new Error(\"Invalid expiration\");\n        const exp = Number.parseInt(expiration, 10);\n        if (exp <= now - opts.timestampSkewSec * 1e3) throw new Error(\"Expired seal\");\n    }\n    let pass = \"\";\n    passwordId = passwordId || \"default\";\n    if (typeof password === \"string\" || password instanceof Uint8Array) pass = password;\n    else if (passwordId in password) {\n        pass = password[passwordId];\n    } else {\n        throw new Error(`Cannot find password: ${passwordId}`);\n    }\n    pass = normalizePassword(pass);\n    const macOptions = opts.integrity;\n    macOptions.salt = hmacSalt;\n    const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n    if (!fixedTimeComparison(mac.digest, hmac)) throw new Error(\"Bad hmac value\");\n    const encrypted = base64urlDecode(encryptedB64);\n    const decryptOptions = opts.encryption;\n    decryptOptions.salt = encryptionSalt;\n    decryptOptions.iv = base64urlDecode(encryptionIv);\n    const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n    if (decrypted) return JSON.parse(decrypted);\n    return null;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcm9uLXdlYmNyeXB0by9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsSUFBSUEscUJBQXFCLENBQUM7QUFDMUIsSUFBSUMsa0JBQWtCQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFHO0FBQzlDLElBQUssSUFBSUMsSUFBSSxHQUFHQyxRQUFRLElBQUlDLFVBQVUsQ0FBQyxJQUFJQyxRQUFRLElBQUlELFVBQVUsQ0FBQyxJQUFJRixJQUFJQyxTQUFTRSxPQUFPSCxJQUFLO0lBQzdGLE1BQU1JLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ04sSUFBSUM7SUFDckNOLGtCQUFrQixDQUFDUyxLQUFLLEdBQUdKO0lBQzNCSixlQUFlLENBQUNJLEVBQUUsR0FBR0k7QUFDdkI7QUFDQSxJQUFLLElBQUlKLElBQUksR0FBR0MsUUFBUSxJQUFJQyxVQUFVLENBQUMsSUFBSUMsUUFBUSxJQUFJRCxVQUFVLENBQUMsSUFBSUYsSUFBSUMsU0FBU0UsT0FBT0gsSUFBSztJQUM3RixNQUFNSSxPQUFPQyxPQUFPQyxZQUFZLENBQUNOLElBQUlDO0lBQ3JDLE1BQU1NLFFBQVFQLElBQUk7SUFDbEJMLGtCQUFrQixDQUFDUyxLQUFLLEdBQUdHO0lBQzNCWCxlQUFlLENBQUNXLE1BQU0sR0FBR0g7QUFDM0I7QUFDQSxJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO0lBQzNCTCxrQkFBa0IsQ0FBQ0ssRUFBRVEsUUFBUSxDQUFDLElBQUksR0FBR1IsSUFBSTtJQUN6QyxNQUFNSSxPQUFPSixFQUFFUSxRQUFRLENBQUM7SUFDeEIsTUFBTUQsUUFBUVAsSUFBSTtJQUNsQkwsa0JBQWtCLENBQUNTLEtBQUssR0FBR0c7SUFDM0JYLGVBQWUsQ0FBQ1csTUFBTSxHQUFHSDtBQUMzQjtBQUNBVCxrQkFBa0IsQ0FBQyxJQUFJLEdBQUc7QUFDMUJDLGVB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QUFDZ0UsV0FBVztJQUM3QixPQUFPO1FBQ0wsTUFBTSxJQUFJbEUsTUFBTSxDQUFDLHNCQUFzQixFQUFFa0UsV0FBVyxDQUFDO0lBQ3ZEO0lBQ0FmLE9BQU9WLGtCQUFrQlU7SUFDekIsTUFBTXNCLGFBQWE1QixLQUFLaEUsU0FBUztJQUNqQzRGLFdBQVd0RSxJQUFJLEdBQUdrRTtJQUNsQixNQUFNYixNQUFNLE1BQU1wQixpQkFBaUJ6QyxTQUFTd0QsS0FBS3RFLFNBQVMsRUFBRTRGLFlBQVlsQjtJQUN4RSxJQUFJLENBQUNHLG9CQUFvQkYsSUFBSWhCLE1BQU0sRUFBRXZCLE9BQ25DLE1BQU0sSUFBSWpCLE1BQU07SUFDbEIsTUFBTWlDLFlBQVlyRixnQkFBZ0J5RztJQUNsQyxNQUFNcUIsaUJBQWlCN0IsS0FBS3JFLFVBQVU7SUFDdENrRyxlQUFldkUsSUFBSSxHQUFHZ0U7SUFDdEJPLGVBQWU5QyxFQUFFLEdBQUdoRixnQkFBZ0J3SDtJQUNwQyxNQUFNakMsWUFBWSxNQUFNRCxRQUFRdkMsU0FBU3dELEtBQUszRSxVQUFVLEVBQUVrRyxnQkFBZ0J6QztJQUMxRSxJQUFJRSxXQUNGLE9BQU9jLEtBQUswQixLQUFLLENBQUN4QztJQUNwQixPQUFPO0FBQ1Q7QUFFaU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZlbnRyeS1hcHAvLi9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcz82NTAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xudmFyIGFscGhhYmV0QnlFbmNvZGluZyA9IHt9O1xudmFyIGFscGhhYmV0QnlWYWx1ZSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDY0IH0pO1xuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJBXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcIlpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpO1xuICBhbHBoYWJldEJ5VmFsdWVbaV0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJhXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcInpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBjb25zdCBpbmRleCA9IGkgKyAyNjtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaW5kZXg7XG4gIGFscGhhYmV0QnlWYWx1ZVtpbmRleF0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tpLnRvU3RyaW5nKDEwKV0gPSBpICsgNTI7XG4gIGNvbnN0IGNoYXIgPSBpLnRvU3RyaW5nKDEwKTtcbiAgY29uc3QgaW5kZXggPSBpICsgNTI7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGluZGV4O1xuICBhbHBoYWJldEJ5VmFsdWVbaW5kZXhdID0gY2hhcjtcbn1cbmFscGhhYmV0QnlFbmNvZGluZ1tcIi1cIl0gPSA2MjtcbmFscGhhYmV0QnlWYWx1ZVs2Ml0gPSBcIi1cIjtcbmFscGhhYmV0QnlFbmNvZGluZ1tcIl9cIl0gPSA2MztcbmFscGhhYmV0QnlWYWx1ZVs2M10gPSBcIl9cIjtcbnZhciBiaXRzUGVyTGV0dGVyID0gNjtcbnZhciBiaXRzUGVyQnl0ZSA9IDg7XG52YXIgbWF4TGV0dGVyVmFsdWUgPSA2MztcbnZhciBzdHJpbmdUb0J1ZmZlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbn07XG52YXIgYnVmZmVyVG9TdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG59O1xudmFyIGJhc2U2NHVybERlY29kZSA9IChfaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBfaW5wdXQgKyBcIj1cIi5yZXBlYXQoKDQgLSBfaW5wdXQubGVuZ3RoICUgNCkgJSA0KTtcbiAgbGV0IHRvdGFsQnl0ZUxlbmd0aCA9IGlucHV0Lmxlbmd0aCAvIDQgKiAzO1xuICBpZiAoaW5wdXQuZW5kc1dpdGgoXCI9PVwiKSkge1xuICAgIHRvdGFsQnl0ZUxlbmd0aCAtPSAyO1xuICB9IGVsc2UgaWYgKGlucHV0LmVuZHNXaXRoKFwiPVwiKSkge1xuICAgIHRvdGFsQnl0ZUxlbmd0aC0tO1xuICB9XG4gIGNvbnN0IG91dCA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbEJ5dGVMZW5ndGgpO1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IGkgKyAzOyBqIDw9IGxpbWl0OyBqKyspIHtcbiAgICAgIGlmIChpbnB1dFtqXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYml0cyA+Pj0gYml0c1BlckxldHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGlucHV0W2pdIGluIGFscGhhYmV0QnlFbmNvZGluZykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAke2lucHV0W2pdfSBpbiBiYXNlNjQgc3RyaW5nLmApO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMgfD0gYWxwaGFiZXRCeUVuY29kaW5nW2lucHV0W2pdXSA8PCAobGltaXQgLSBqKSAqIGJpdHNQZXJMZXR0ZXI7XG4gICAgICAgIGJpdExlbmd0aCArPSBiaXRzUGVyTGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaHVua09mZnNldCA9IGkgLyA0ICogMztcbiAgICBiaXRzID4+PSBiaXRMZW5ndGggJSBiaXRzUGVyQnl0ZTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5mbG9vcihiaXRMZW5ndGggLyBiaXRzUGVyQnl0ZSk7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBieXRlTGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChieXRlTGVuZ3RoIC0gayAtIDEpICogYml0c1BlckJ5dGU7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChjaHVua09mZnNldCArIGssIChiaXRzICYgMjU1IDw8IG9mZnNldCkgPj4gb2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dCk7XG59O1xudmFyIGJhc2U2NHVybEVuY29kZSA9IChfaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXQgPSB0eXBlb2YgX2lucHV0ID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9CdWZmZXIoX2lucHV0KSA6IF9pbnB1dDtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJpdExlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGksIGxpbWl0ID0gTWF0aC5taW4oaSArIDMsIGlucHV0Lmxlbmd0aCk7IGogPCBsaW1pdDsgaisrKSB7XG4gICAgICBiaXRzIHw9IGlucHV0W2pdIDw8IChsaW1pdCAtIGogLSAxKSAqIGJpdHNQZXJCeXRlO1xuICAgICAgYml0TGVuZ3RoICs9IGJpdHNQZXJCeXRlO1xuICAgIH1cbiAgICBjb25zdCBiaXRDbHVzdGVyQ291bnQgPSBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gYml0c1BlckxldHRlcik7XG4gICAgYml0cyA8PD0gYml0Q2x1c3RlckNvdW50ICogYml0c1BlckxldHRlciAtIGJpdExlbmd0aDtcbiAgICBmb3IgKGxldCBrID0gMTsgayA8PSBiaXRDbHVzdGVyQ291bnQ7IGsrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGJpdENsdXN0ZXJDb3VudCAtIGspICogYml0c1BlckxldHRlcjtcbiAgICAgIHN0ciArPSBhbHBoYWJldEJ5VmFsdWVbKGJpdHMgJiBtYXhMZXR0ZXJWYWx1ZSA8PCBvZmZzZXQpID4+IG9mZnNldF07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBkZWZhdWx0cyA9IHtcbiAgZW5jcnlwdGlvbjogeyBzYWx0Qml0czogMjU2LCBhbGdvcml0aG06IFwiYWVzLTI1Ni1jYmNcIiwgaXRlcmF0aW9uczogMSwgbWluUGFzc3dvcmRsZW5ndGg6IDMyIH0sXG4gIGludGVncml0eTogeyBzYWx0Qml0czogMjU2LCBhbGdvcml0aG06IFwic2hhMjU2XCIsIGl0ZXJhdGlvbnM6IDEsIG1pblBhc3N3b3JkbGVuZ3RoOiAzMiB9LFxuICB0dGw6IDAsXG4gIHRpbWVzdGFtcFNrZXdTZWM6IDYwLFxuICBsb2NhbHRpbWVPZmZzZXRNc2VjOiAwXG59O1xudmFyIGNsb25lID0gKG9wdGlvbnMpID0+ICh7XG4gIC4uLm9wdGlvbnMsXG4gIGVuY3J5cHRpb246IHsgLi4ub3B0aW9ucy5lbmNyeXB0aW9uIH0sXG4gIGludGVncml0eTogeyAuLi5vcHRpb25zLmludGVncml0eSB9XG59KTtcbnZhciBhbGdvcml0aG1zID0ge1xuICBcImFlcy0xMjgtY3RyXCI6IHsga2V5Qml0czogMTI4LCBpdkJpdHM6IDEyOCwgbmFtZTogXCJBRVMtQ1RSXCIgfSxcbiAgXCJhZXMtMjU2LWNiY1wiOiB7IGtleUJpdHM6IDI1NiwgaXZCaXRzOiAxMjgsIG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gIHNoYTI1NjogeyBrZXlCaXRzOiAyNTYsIG5hbWU6IFwiU0hBLTI1NlwiIH1cbn07XG52YXIgbWFjRm9ybWF0VmVyc2lvbiA9IFwiMlwiO1xudmFyIG1hY1ByZWZpeCA9IFwiRmUyNi4yXCI7XG52YXIgcmFuZG9tQnl0ZXMgPSAoX2NyeXB0bywgc2l6ZSkgPT4ge1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gIHJldHVybiBieXRlcztcbn07XG52YXIgcmFuZG9tQml0cyA9IChfY3J5cHRvLCBiaXRzKSA9PiB7XG4gIGlmIChiaXRzIDwgMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJhbmRvbSBiaXRzIGNvdW50XCIpO1xuICBjb25zdCBieXRlcyA9IE1hdGguY2VpbChiaXRzIC8gOCk7XG4gIHJldHVybiByYW5kb21CeXRlcyhfY3J5cHRvLCBieXRlcyk7XG59O1xudmFyIHBia2RmMiA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5TGVuZ3RoLCBoYXNoKSA9PiB7XG4gIGNvbnN0IHBhc3N3b3JkQnVmZmVyID0gc3RyaW5nVG9CdWZmZXIocGFzc3dvcmQpO1xuICBjb25zdCBpbXBvcnRlZEtleSA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInJhd1wiLFxuICAgIHBhc3N3b3JkQnVmZmVyLFxuICAgIHsgbmFtZTogXCJQQktERjJcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcImRlcml2ZUJpdHNcIl1cbiAgKTtcbiAgY29uc3Qgc2FsdEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHNhbHQpO1xuICBjb25zdCBwYXJhbXMgPSB7IG5hbWU6IFwiUEJLREYyXCIsIGhhc2gsIHNhbHQ6IHNhbHRCdWZmZXIsIGl0ZXJhdGlvbnMgfTtcbiAgY29uc3QgZGVyaXZhdGlvbiA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMocGFyYW1zLCBpbXBvcnRlZEtleSwga2V5TGVuZ3RoICogOCk7XG4gIHJldHVybiBkZXJpdmF0aW9uO1xufTtcbnZhciBnZW5lcmF0ZUtleSA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICB2YXIgX2E7XG4gIGlmICghKHBhc3N3b3JkID09IG51bGwgPyB2b2lkIDAgOiBwYXNzd29yZC5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBvcHRpb25zXCIpO1xuICBpZiAoIShvcHRpb25zLmFsZ29yaXRobSBpbiBhbGdvcml0aG1zKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWxnb3JpdGhtOiAke29wdGlvbnMuYWxnb3JpdGhtfWApO1xuICBjb25zdCBhbGdvcml0aG0gPSBhbGdvcml0aG1zW29wdGlvbnMuYWxnb3JpdGhtXTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGhtYWMgPSAoX2EgPSBvcHRpb25zLmhtYWMpICE9IG51bGwgPyBfYSA6IGZhbHNlO1xuICBjb25zdCBpZCA9IGhtYWMgPyB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBhbGdvcml0aG0ubmFtZSB9IDogeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9O1xuICBjb25zdCB1c2FnZSA9IGhtYWMgPyBbXCJzaWduXCIsIFwidmVyaWZ5XCJdIDogW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl07XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgb3B0aW9ucy5taW5QYXNzd29yZGxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhc3N3b3JkIHN0cmluZyB0b28gc2hvcnQgKG1pbiAke29wdGlvbnMubWluUGFzc3dvcmRsZW5ndGh9IGNoYXJhY3RlcnMgcmVxdWlyZWQpYFxuICAgICAgKTtcbiAgICBsZXQgeyBzYWx0ID0gXCJcIiB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNhbHQpIHtcbiAgICAgIGNvbnN0IHsgc2FsdEJpdHMgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKCFzYWx0Qml0cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzYWx0IGFuZCBzYWx0Qml0cyBvcHRpb25zXCIpO1xuICAgICAgY29uc3QgcmFuZG9tU2FsdCA9IHJhbmRvbUJpdHMoX2NyeXB0bywgc2FsdEJpdHMpO1xuICAgICAgc2FsdCA9IFsuLi5uZXcgVWludDhBcnJheShyYW5kb21TYWx0KV0ubWFwKCh4KSA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBhd2FpdCBwYmtkZjIoXG4gICAgICBfY3J5cHRvLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBzYWx0LFxuICAgICAgb3B0aW9ucy5pdGVyYXRpb25zLFxuICAgICAgYWxnb3JpdGhtLmtleUJpdHMgLyA4LFxuICAgICAgXCJTSEEtMVwiXG4gICAgKTtcbiAgICBjb25zdCBpbXBvcnRlZEVuY3J5cHRpb25LZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICBcInJhd1wiLFxuICAgICAgZGVyaXZlZEtleSxcbiAgICAgIGlkLFxuICAgICAgZmFsc2UsXG4gICAgICB1c2FnZVxuICAgICk7XG4gICAgcmVzdWx0LmtleSA9IGltcG9ydGVkRW5jcnlwdGlvbktleTtcbiAgICByZXN1bHQuc2FsdCA9IHNhbHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IGFsZ29yaXRobS5rZXlCaXRzIC8gOClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBidWZmZXIgKHBhc3N3b3JkKSB0b28gc21hbGxcIik7XG4gICAgcmVzdWx0LmtleSA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBwYXNzd29yZCwgaWQsIGZhbHNlLCB1c2FnZSk7XG4gICAgcmVzdWx0LnNhbHQgPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLml2KVxuICAgIHJlc3VsdC5pdiA9IG9wdGlvbnMuaXY7XG4gIGVsc2UgaWYgKFwiaXZCaXRzXCIgaW4gYWxnb3JpdGhtKVxuICAgIHJlc3VsdC5pdiA9IHJhbmRvbUJpdHMoX2NyeXB0bywgYWxnb3JpdGhtLml2Qml0cyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGdldEVuY3J5cHRQYXJhbXMgPSAoYWxnb3JpdGhtLCBrZXksIGRhdGEpID0+IHtcbiAgcmV0dXJuIFtcbiAgICBhbGdvcml0aG0gPT09IFwiYWVzLTEyOC1jdHJcIiA/IHsgbmFtZTogXCJBRVMtQ1RSXCIsIGNvdW50ZXI6IGtleS5pdiwgbGVuZ3RoOiAxMjggfSA6IHsgbmFtZTogXCJBRVMtQ0JDXCIsIGl2OiBrZXkuaXYgfSxcbiAgICBrZXkua2V5LFxuICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9CdWZmZXIoZGF0YSkgOiBkYXRhXG4gIF07XG59O1xudmFyIGVuY3J5cHQgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5lbmNyeXB0KC4uLmdldEVuY3J5cHRQYXJhbXMob3B0aW9ucy5hbGdvcml0aG0sIGtleSwgZGF0YSkpO1xuICByZXR1cm4geyBlbmNyeXB0ZWQ6IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCksIGtleSB9O1xufTtcbnZhciBkZWNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuZGVjcnlwdCguLi5nZXRFbmNyeXB0UGFyYW1zKG9wdGlvbnMuYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbiAgcmV0dXJuIGJ1ZmZlclRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCkpO1xufTtcbnZhciBobWFjV2l0aFBhc3N3b3JkID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCB7IC4uLm9wdGlvbnMsIGhtYWM6IHRydWUgfSk7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihkYXRhKTtcbiAgY29uc3Qgc2lnbmVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuc2lnbih7IG5hbWU6IFwiSE1BQ1wiIH0sIGtleS5rZXksIHRleHRCdWZmZXIpO1xuICBjb25zdCBkaWdlc3QgPSBiYXNlNjR1cmxFbmNvZGUobmV3IFVpbnQ4QXJyYXkoc2lnbmVkKSk7XG4gIHJldHVybiB7IGRpZ2VzdCwgc2FsdDoga2V5LnNhbHQgfTtcbn07XG52YXIgbm9ybWFsaXplUGFzc3dvcmQgPSAocGFzc3dvcmQpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIiB8fCBwYXNzd29yZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgcmV0dXJuIHsgZW5jcnlwdGlvbjogcGFzc3dvcmQsIGludGVncml0eTogcGFzc3dvcmQgfTtcbiAgaWYgKFwic2VjcmV0XCIgaW4gcGFzc3dvcmQpXG4gICAgcmV0dXJuIHsgaWQ6IHBhc3N3b3JkLmlkLCBlbmNyeXB0aW9uOiBwYXNzd29yZC5zZWNyZXQsIGludGVncml0eTogcGFzc3dvcmQuc2VjcmV0IH07XG4gIHJldHVybiB7IGlkOiBwYXNzd29yZC5pZCwgZW5jcnlwdGlvbjogcGFzc3dvcmQuZW5jcnlwdGlvbiwgaW50ZWdyaXR5OiBwYXNzd29yZC5pbnRlZ3JpdHkgfTtcbn07XG52YXIgc2VhbCA9IGFzeW5jIChfY3J5cHRvLCBvYmplY3QsIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcGFzc3dvcmQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGNvbnN0IG9wdHMgPSBjbG9uZShvcHRpb25zKTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSArIChvcHRzLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XG4gIGNvbnN0IG9iamVjdFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gIGNvbnN0IHBhc3MgPSBub3JtYWxpemVQYXNzd29yZChwYXNzd29yZCk7XG4gIGNvbnN0IHsgaWQgPSBcIlwiLCBlbmNyeXB0aW9uLCBpbnRlZ3JpdHkgfSA9IHBhc3M7XG4gIGlmIChpZCAmJiAhL15cXHcrJC8udGVzdChpZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXNzd29yZCBpZFwiKTtcbiAgY29uc3QgeyBlbmNyeXB0ZWQsIGtleSB9ID0gYXdhaXQgZW5jcnlwdChfY3J5cHRvLCBlbmNyeXB0aW9uLCBvcHRzLmVuY3J5cHRpb24sIG9iamVjdFN0cmluZyk7XG4gIGNvbnN0IGVuY3J5cHRlZEI2NCA9IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcbiAgY29uc3QgaXYgPSBiYXNlNjR1cmxFbmNvZGUoa2V5Lml2KTtcbiAgY29uc3QgZXhwaXJhdGlvbiA9IG9wdHMudHRsID8gbm93ICsgb3B0cy50dGwgOiBcIlwiO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7bWFjUHJlZml4fSoke2lkfSoke2tleS5zYWx0fSoke2l2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgaW50ZWdyaXR5LCBvcHRzLmludGVncml0eSwgbWFjQmFzZVN0cmluZyk7XG4gIGNvbnN0IHNlYWxlZCA9IGAke21hY0Jhc2VTdHJpbmd9KiR7bWFjLnNhbHR9KiR7bWFjLmRpZ2VzdH1gO1xuICByZXR1cm4gc2VhbGVkO1xufTtcbnZhciBmaXhlZFRpbWVDb21wYXJpc29uID0gKGEsIGIpID0+IHtcbiAgbGV0IG1pc21hdGNoID0gYS5sZW5ndGggPT09IGIubGVuZ3RoID8gMCA6IDE7XG4gIGlmIChtaXNtYXRjaClcbiAgICBiID0gYTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKVxuICAgIG1pc21hdGNoIHw9IGEuY2hhckNvZGVBdChpKSBeIGIuY2hhckNvZGVBdChpKTtcbiAgcmV0dXJuIG1pc21hdGNoID09PSAwO1xufTtcbnZhciB1bnNlYWwgPSBhc3luYyAoX2NyeXB0bywgc2VhbGVkLCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIXBhc3N3b3JkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBjb25zdCBvcHRzID0gY2xvbmUob3B0aW9ucyk7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCkgKyAob3B0cy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApO1xuICBjb25zdCBwYXJ0cyA9IHNlYWxlZC5zcGxpdChcIipcIik7XG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBzZWFsZWQgY29tcG9uZW50c1wiKTtcbiAgY29uc3QgcHJlZml4ID0gcGFydHNbMF07XG4gIGxldCBwYXNzd29yZElkID0gcGFydHNbMV07XG4gIGNvbnN0IGVuY3J5cHRpb25TYWx0ID0gcGFydHNbMl07XG4gIGNvbnN0IGVuY3J5cHRpb25JdiA9IHBhcnRzWzNdO1xuICBjb25zdCBlbmNyeXB0ZWRCNjQgPSBwYXJ0c1s0XTtcbiAgY29uc3QgZXhwaXJhdGlvbiA9IHBhcnRzWzVdO1xuICBjb25zdCBobWFjU2FsdCA9IHBhcnRzWzZdO1xuICBjb25zdCBobWFjID0gcGFydHNbN107XG4gIGNvbnN0IG1hY0Jhc2VTdHJpbmcgPSBgJHtwcmVmaXh9KiR7cGFzc3dvcmRJZH0qJHtlbmNyeXB0aW9uU2FsdH0qJHtlbmNyeXB0aW9uSXZ9KiR7ZW5jcnlwdGVkQjY0fSoke2V4cGlyYXRpb259YDtcbiAgaWYgKG1hY1ByZWZpeCAhPT0gcHJlZml4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIG1hYyBwcmVmaXhcIik7XG4gIGlmIChleHBpcmF0aW9uKSB7XG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KGV4cGlyYXRpb24pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHBpcmF0aW9uXCIpO1xuICAgIGNvbnN0IGV4cCA9IE51bWJlci5wYXJzZUludChleHBpcmF0aW9uLCAxMCk7XG4gICAgaWYgKGV4cCA8PSBub3cgLSBvcHRzLnRpbWVzdGFtcFNrZXdTZWMgKiAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVkIHNlYWxcIik7XG4gIH1cbiAgbGV0IHBhc3MgPSBcIlwiO1xuICBwYXNzd29yZElkID0gcGFzc3dvcmRJZCB8fCBcImRlZmF1bHRcIjtcbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIiB8fCBwYXNzd29yZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgcGFzcyA9IHBhc3N3b3JkO1xuICBlbHNlIGlmIChwYXNzd29yZElkIGluIHBhc3N3b3JkKSB7XG4gICAgcGFzcyA9IHBhc3N3b3JkW3Bhc3N3b3JkSWRdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgcGFzc3dvcmQ6ICR7cGFzc3dvcmRJZH1gKTtcbiAgfVxuICBwYXNzID0gbm9ybWFsaXplUGFzc3dvcmQocGFzcyk7XG4gIGNvbnN0IG1hY09wdGlvbnMgPSBvcHRzLmludGVncml0eTtcbiAgbWFjT3B0aW9ucy5zYWx0ID0gaG1hY1NhbHQ7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgcGFzcy5pbnRlZ3JpdHksIG1hY09wdGlvbnMsIG1hY0Jhc2VTdHJpbmcpO1xuICBpZiAoIWZpeGVkVGltZUNvbXBhcmlzb24obWFjLmRpZ2VzdCwgaG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGhtYWMgdmFsdWVcIik7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0ZWRCNjQpO1xuICBjb25zdCBkZWNyeXB0T3B0aW9ucyA9IG9wdHMuZW5jcnlwdGlvbjtcbiAgZGVjcnlwdE9wdGlvbnMuc2FsdCA9IGVuY3J5cHRpb25TYWx0O1xuICBkZWNyeXB0T3B0aW9ucy5pdiA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0aW9uSXYpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBkZWNyeXB0KF9jcnlwdG8sIHBhc3MuZW5jcnlwdGlvbiwgZGVjcnlwdE9wdGlvbnMsIGVuY3J5cHRlZCk7XG4gIGlmIChkZWNyeXB0ZWQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBhbGdvcml0aG1zLCBiYXNlNjR1cmxEZWNvZGUsIGJhc2U2NHVybEVuY29kZSwgYnVmZmVyVG9TdHJpbmcsIGNsb25lLCBkZWNyeXB0LCBkZWZhdWx0cywgZW5jcnlwdCwgZ2VuZXJhdGVLZXksIGhtYWNXaXRoUGFzc3dvcmQsIG1hY0Zvcm1hdFZlcnNpb24sIG1hY1ByZWZpeCwgcmFuZG9tQml0cywgc2VhbCwgc3RyaW5nVG9CdWZmZXIsIHVuc2VhbCB9O1xuIl0sIm5hbWVzIjpbImFscGhhYmV0QnlFbmNvZGluZyIsImFscGhhYmV0QnlWYWx1ZSIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsImkiLCJzdGFydCIsImNoYXJDb2RlQXQiLCJsaW1pdCIsImNoYXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpbmRleCIsInRvU3RyaW5nIiwiYml0c1BlckxldHRlciIsImJpdHNQZXJCeXRlIiwibWF4TGV0dGVyVmFsdWUiLCJzdHJpbmdUb0J1ZmZlciIsInZhbHVlIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJidWZmZXJUb1N0cmluZyIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiYmFzZTY0dXJsRGVjb2RlIiwiX2lucHV0IiwiaW5wdXQiLCJyZXBlYXQiLCJ0b3RhbEJ5dGVMZW5ndGgiLCJlbmRzV2l0aCIsIm91dCIsIkFycmF5QnVmZmVyIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImJpdHMiLCJiaXRMZW5ndGgiLCJqIiwiVHlwZUVycm9yIiwiY2h1bmtPZmZzZXQiLCJieXRlTGVuZ3RoIiwiTWF0aCIsImZsb29yIiwiayIsIm9mZnNldCIsInNldFVpbnQ4IiwiVWludDhBcnJheSIsImJhc2U2NHVybEVuY29kZSIsInN0ciIsIm1pbiIsImJpdENsdXN0ZXJDb3VudCIsImNlaWwiLCJkZWZhdWx0cyIsImVuY3J5cHRpb24iLCJzYWx0Qml0cyIsImFsZ29yaXRobSIsIml0ZXJhdGlvbnMiLCJtaW5QYXNzd29yZGxlbmd0aCIsImludGVncml0eSIsInR0bCIsInRpbWVzdGFtcFNrZXdTZWMiLCJsb2NhbHRpbWVPZmZzZXRNc2VjIiwiY2xvbmUiLCJvcHRpb25zIiwiYWxnb3JpdGhtcyIsImtleUJpdHMiLCJpdkJpdHMiLCJuYW1lIiwic2hhMjU2IiwibWFjRm9ybWF0VmVyc2lvbiIsIm1hY1ByZWZpeCIsInJhbmRvbUJ5dGVzIiwiX2NyeXB0byIsInNpemUiLCJieXRlcyIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJpdHMiLCJFcnJvciIsInBia2RmMiIsInBhc3N3b3JkIiwic2FsdCIsImtleUxlbmd0aCIsImhhc2giLCJwYXNzd29yZEJ1ZmZlciIsImltcG9ydGVkS2V5Iiwic3VidGxlIiwiaW1wb3J0S2V5Iiwic2FsdEJ1ZmZlciIsInBhcmFtcyIsImRlcml2YXRpb24iLCJkZXJpdmVCaXRzIiwiZ2VuZXJhdGVLZXkiLCJfYSIsInJlc3VsdCIsImhtYWMiLCJpZCIsInVzYWdlIiwicmFuZG9tU2FsdCIsIm1hcCIsIngiLCJwYWRTdGFydCIsImpvaW4iLCJkZXJpdmVkS2V5IiwiaW1wb3J0ZWRFbmNyeXB0aW9uS2V5Iiwia2V5IiwiaXYiLCJnZXRFbmNyeXB0UGFyYW1zIiwiZGF0YSIsImNvdW50ZXIiLCJlbmNyeXB0IiwiZW5jcnlwdGVkIiwiZGVjcnlwdCIsImRlY3J5cHRlZCIsImhtYWNXaXRoUGFzc3dvcmQiLCJ0ZXh0QnVmZmVyIiwic2lnbmVkIiwic2lnbiIsImRpZ2VzdCIsIm5vcm1hbGl6ZVBhc3N3b3JkIiwic2VjcmV0Iiwic2VhbCIsIm9iamVjdCIsIm9wdHMiLCJub3ciLCJEYXRlIiwib2JqZWN0U3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhc3MiLCJ0ZXN0IiwiZW5jcnlwdGVkQjY0IiwiZXhwaXJhdGlvbiIsIm1hY0Jhc2VTdHJpbmciLCJtYWMiLCJzZWFsZWQiLCJmaXhlZFRpbWVDb21wYXJpc29uIiwiYSIsImIiLCJtaXNtYXRjaCIsInVuc2VhbCIsInBhcnRzIiwic3BsaXQiLCJwcmVmaXgiLCJwYXNzd29yZElkIiwiZW5jcnlwdGlvblNhbHQiLCJlbmNyeXB0aW9uSXYiLCJobWFjU2FsdCIsImV4cCIsIk51bWJlciIsInBhcnNlSW50IiwibWFjT3B0aW9ucyIsImRlY3J5cHRPcHRpb25zIiwicGFyc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/iron-webcrypto/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/iron-webcrypto/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/iron-webcrypto/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// src/utils.ts\nvar alphabetByEncoding = {};\nvar alphabetByValue = Array.from({\n    length: 64\n});\nfor(let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor(let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    const index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor(let i = 0; i < 10; i++){\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    const char = i.toString(10);\n    const index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"-\"] = 62;\nalphabetByValue[62] = \"-\";\nalphabetByEncoding[\"_\"] = 63;\nalphabetByValue[63] = \"_\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nvar stringToBuffer = (value)=>{\n    return new TextEncoder().encode(value);\n};\nvar bufferToString = (value)=>{\n    return new TextDecoder().decode(value);\n};\nvar base64urlDecode = (_input)=>{\n    const input = _input + \"=\".repeat((4 - _input.length % 4) % 4);\n    let totalByteLength = input.length / 4 * 3;\n    if (input.endsWith(\"==\")) {\n        totalByteLength -= 2;\n    } else if (input.endsWith(\"=\")) {\n        totalByteLength--;\n    }\n    const out = new ArrayBuffer(totalByteLength);\n    const dataView = new DataView(out);\n    for(let i = 0; i < input.length; i += 4){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = i + 3; j <= limit; j++){\n            if (input[j] === \"=\") {\n                bits >>= bitsPerLetter;\n            } else {\n                if (!(input[j] in alphabetByEncoding)) {\n                    throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n                }\n                bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n                bitLength += bitsPerLetter;\n            }\n        }\n        const chunkOffset = i / 4 * 3;\n        bits >>= bitLength % bitsPerByte;\n        const byteLength = Math.floor(bitLength / bitsPerByte);\n        for(let k = 0; k < byteLength; k++){\n            const offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n};\nvar base64urlEncode = (_input)=>{\n    const input = typeof _input === \"string\" ? stringToBuffer(_input) : _input;\n    let str = \"\";\n    for(let i = 0; i < input.length; i += 3){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = Math.min(i + 3, input.length); j < limit; j++){\n            bits |= input[j] << (limit - j - 1) * bitsPerByte;\n            bitLength += bitsPerByte;\n        }\n        const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for(let k = 1; k <= bitClusterCount; k++){\n            const offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n        }\n    }\n    return str;\n};\n// src/index.ts\nvar defaults = {\n    encryption: {\n        saltBits: 256,\n        algorithm: \"aes-256-cbc\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    integrity: {\n        saltBits: 256,\n        algorithm: \"sha256\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    ttl: 0,\n    timestampSkewSec: 60,\n    localtimeOffsetMsec: 0\n};\nvar clone = (options)=>({\n        ...options,\n        encryption: {\n            ...options.encryption\n        },\n        integrity: {\n            ...options.integrity\n        }\n    });\nvar algorithms = {\n    \"aes-128-ctr\": {\n        keyBits: 128,\n        ivBits: 128,\n        name: \"AES-CTR\"\n    },\n    \"aes-256-cbc\": {\n        keyBits: 256,\n        ivBits: 128,\n        name: \"AES-CBC\"\n    },\n    sha256: {\n        keyBits: 256,\n        name: \"SHA-256\"\n    }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = \"Fe26.2\";\nvar randomBytes = (_crypto, size)=>{\n    const bytes = new Uint8Array(size);\n    _crypto.getRandomValues(bytes);\n    return bytes;\n};\nvar randomBits = (_crypto, bits)=>{\n    if (bits < 1) throw new Error(\"Invalid random bits count\");\n    const bytes = Math.ceil(bits / 8);\n    return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash)=>{\n    const passwordBuffer = stringToBuffer(password);\n    const importedKey = await _crypto.subtle.importKey(\"raw\", passwordBuffer, {\n        name: \"PBKDF2\"\n    }, false, [\n        \"deriveBits\"\n    ]);\n    const saltBuffer = stringToBuffer(salt);\n    const params = {\n        name: \"PBKDF2\",\n        hash,\n        salt: saltBuffer,\n        iterations\n    };\n    const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n    return derivation;\n};\nvar generateKey = async (_crypto, password, options)=>{\n    var _a;\n    if (!(password == null ? void 0 : password.length)) throw new Error(\"Empty password\");\n    if (options == null || typeof options !== \"object\") throw new Error(\"Bad options\");\n    if (!(options.algorithm in algorithms)) throw new Error(`Unknown algorithm: ${options.algorithm}`);\n    const algorithm = algorithms[options.algorithm];\n    const result = {};\n    const hmac = (_a = options.hmac) != null ? _a : false;\n    const id = hmac ? {\n        name: \"HMAC\",\n        hash: algorithm.name\n    } : {\n        name: algorithm.name\n    };\n    const usage = hmac ? [\n        \"sign\",\n        \"verify\"\n    ] : [\n        \"encrypt\",\n        \"decrypt\"\n    ];\n    if (typeof password === \"string\") {\n        if (password.length < options.minPasswordlength) throw new Error(`Password string too short (min ${options.minPasswordlength} characters required)`);\n        let { salt = \"\" } = options;\n        if (!salt) {\n            const { saltBits = 0 } = options;\n            if (!saltBits) throw new Error(\"Missing salt and saltBits options\");\n            const randomSalt = randomBits(_crypto, saltBits);\n            salt = [\n                ...new Uint8Array(randomSalt)\n            ].map((x)=>x.toString(16).padStart(2, \"0\")).join(\"\");\n        }\n        const derivedKey = await pbkdf2(_crypto, password, salt, options.iterations, algorithm.keyBits / 8, \"SHA-1\");\n        const importedEncryptionKey = await _crypto.subtle.importKey(\"raw\", derivedKey, id, false, usage);\n        result.key = importedEncryptionKey;\n        result.salt = salt;\n    } else {\n        if (password.length < algorithm.keyBits / 8) throw new Error(\"Key buffer (password) too small\");\n        result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n        result.salt = \"\";\n    }\n    if (options.iv) result.iv = options.iv;\n    else if (\"ivBits\" in algorithm) result.iv = randomBits(_crypto, algorithm.ivBits);\n    return result;\n};\nvar getEncryptParams = (algorithm, key, data)=>{\n    return [\n        algorithm === \"aes-128-ctr\" ? {\n            name: \"AES-CTR\",\n            counter: key.iv,\n            length: 128\n        } : {\n            name: \"AES-CBC\",\n            iv: key.iv\n        },\n        key.key,\n        typeof data === \"string\" ? stringToBuffer(data) : data\n    ];\n};\nvar encrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const encrypted = await _crypto.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));\n    return {\n        encrypted: new Uint8Array(encrypted),\n        key\n    };\n};\nvar decrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const decrypted = await _crypto.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));\n    return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, {\n        ...options,\n        hmac: true\n    });\n    const textBuffer = stringToBuffer(data);\n    const signed = await _crypto.subtle.sign({\n        name: \"HMAC\"\n    }, key.key, textBuffer);\n    const digest = base64urlEncode(new Uint8Array(signed));\n    return {\n        digest,\n        salt: key.salt\n    };\n};\nvar normalizePassword = (password)=>{\n    if (typeof password === \"string\" || password instanceof Uint8Array) return {\n        encryption: password,\n        integrity: password\n    };\n    if (\"secret\" in password) return {\n        id: password.id,\n        encryption: password.secret,\n        integrity: password.secret\n    };\n    return {\n        id: password.id,\n        encryption: password.encryption,\n        integrity: password.integrity\n    };\n};\nvar seal = async (_crypto, object, password, options)=>{\n    if (!password) throw new Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const objectString = JSON.stringify(object);\n    const pass = normalizePassword(password);\n    const { id = \"\", encryption, integrity } = pass;\n    if (id && !/^\\w+$/.test(id)) throw new Error(\"Invalid password id\");\n    const { encrypted, key } = await encrypt(_crypto, encryption, opts.encryption, objectString);\n    const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n    const iv = base64urlEncode(key.iv);\n    const expiration = opts.ttl ? now + opts.ttl : \"\";\n    const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n    const mac = await hmacWithPassword(_crypto, integrity, opts.integrity, macBaseString);\n    const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n    return sealed;\n};\nvar fixedTimeComparison = (a, b)=>{\n    let mismatch = a.length === b.length ? 0 : 1;\n    if (mismatch) b = a;\n    for(let i = 0; i < a.length; i += 1)mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options)=>{\n    if (!password) throw new Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const parts = sealed.split(\"*\");\n    if (parts.length !== 8) throw new Error(\"Incorrect number of sealed components\");\n    const prefix = parts[0];\n    let passwordId = parts[1];\n    const encryptionSalt = parts[2];\n    const encryptionIv = parts[3];\n    const encryptedB64 = parts[4];\n    const expiration = parts[5];\n    const hmacSalt = parts[6];\n    const hmac = parts[7];\n    const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n    if (macPrefix !== prefix) throw new Error(\"Wrong mac prefix\");\n    if (expiration) {\n        if (!/^\\d+$/.test(expiration)) throw new Error(\"Invalid expiration\");\n        const exp = Number.parseInt(expiration, 10);\n        if (exp <= now - opts.timestampSkewSec * 1e3) throw new Error(\"Expired seal\");\n    }\n    let pass = \"\";\n    passwordId = passwordId || \"default\";\n    if (typeof password === \"string\" || password instanceof Uint8Array) pass = password;\n    else if (passwordId in password) {\n        pass = password[passwordId];\n    } else {\n        throw new Error(`Cannot find password: ${passwordId}`);\n    }\n    pass = normalizePassword(pass);\n    const macOptions = opts.integrity;\n    macOptions.salt = hmacSalt;\n    const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n    if (!fixedTimeComparison(mac.digest, hmac)) throw new Error(\"Bad hmac value\");\n    const encrypted = base64urlDecode(encryptedB64);\n    const decryptOptions = opts.encryption;\n    decryptOptions.salt = encryptionSalt;\n    decryptOptions.iv = base64urlDecode(encryptionIv);\n    const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n    if (decrypted) return JSON.parse(decrypted);\n    return null;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNmLElBQUlBLHFCQUFxQixDQUFDO0FBQzFCLElBQUlDLGtCQUFrQkMsTUFBTUMsSUFBSSxDQUFDO0lBQUVDLFFBQVE7QUFBRztBQUM5QyxJQUFLLElBQUlDLElBQUksR0FBR0MsUUFBUSxJQUFJQyxVQUFVLENBQUMsSUFBSUMsUUFBUSxJQUFJRCxVQUFVLENBQUMsSUFBSUYsSUFBSUMsU0FBU0UsT0FBT0gsSUFBSztJQUM3RixNQUFNSSxPQUFPQyxPQUFPQyxZQUFZLENBQUNOLElBQUlDO0lBQ3JDTixrQkFBa0IsQ0FBQ1MsS0FBSyxHQUFHSjtJQUMzQkosZUFBZSxDQUFDSSxFQUFFLEdBQUdJO0FBQ3ZCO0FBQ0EsSUFBSyxJQUFJSixJQUFJLEdBQUdDLFFBQVEsSUFBSUMsVUFBVSxDQUFDLElBQUlDLFFBQVEsSUFBSUQsVUFBVSxDQUFDLElBQUlGLElBQUlDLFNBQVNFLE9BQU9ILElBQUs7SUFDN0YsTUFBTUksT0FBT0MsT0FBT0MsWUFBWSxDQUFDTixJQUFJQztJQUNyQyxNQUFNTSxRQUFRUCxJQUFJO0lBQ2xCTCxrQkFBa0IsQ0FBQ1MsS0FBSyxHQUFHRztJQUMzQlgsZUFBZSxDQUFDVyxNQUFNLEdBQUdIO0FBQzNCO0FBQ0EsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztJQUMzQkwsa0JBQWtCLENBQUNLLEVBQUVRLFFBQVEsQ0FBQyxJQUFJLEdBQUdSLElBQUk7SUFDekMsTUFBTUksT0FBT0osRUFBRVEsUUFBUSxDQUFDO0lBQ3hCLE1BQU1ELFFBQVFQLElBQUk7SUFDbEJMLGtCQUFrQixDQUFDUyxLQUFLLEdBQUdHO0lBQzNCWCxlQUFlLENBQUNXLE1BQU0sR0FBR0g7QUFDM0I7QUFDQVQsa0JBQWtCLENBQUMsSUFBSSxHQUFHO0FBQzFCQyxlQUFlLENBQUMsR0FB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SUFDN0IsT0FBTztRQUNMLE1BQU0sSUFBSWxFLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRWtFLFdBQVcsQ0FBQztJQUN2RDtJQUNBZixPQUFPVixrQkFBa0JVO0lBQ3pCLE1BQU1zQixhQUFhNUIsS0FBS2hFLFNBQVM7SUFDakM0RixXQUFXdEUsSUFBSSxHQUFHa0U7SUFDbEIsTUFBTWIsTUFBTSxNQUFNcEIsaUJBQWlCekMsU0FBU3dELEtBQUt0RSxTQUFTLEVBQUU0RixZQUFZbEI7SUFDeEUsSUFBSSxDQUFDRyxvQkFBb0JGLElBQUloQixNQUFNLEVBQUV2QixPQUNuQyxNQUFNLElBQUlqQixNQUFNO0lBQ2xCLE1BQU1pQyxZQUFZckYsZ0JBQWdCeUc7SUFDbEMsTUFBTXFCLGlCQUFpQjdCLEtBQUtyRSxVQUFVO0lBQ3RDa0csZUFBZXZFLElBQUksR0FBR2dFO0lBQ3RCTyxlQUFlOUMsRUFBRSxHQUFHaEYsZ0JBQWdCd0g7SUFDcEMsTUFBTWpDLFlBQVksTUFBTUQsUUFBUXZDLFNBQVN3RCxLQUFLM0UsVUFBVSxFQUFFa0csZ0JBQWdCekM7SUFDMUUsSUFBSUUsV0FDRixPQUFPYyxLQUFLMEIsS0FBSyxDQUFDeEM7SUFDcEIsT0FBTztBQUNUO0FBRWlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52ZW50cnktYXBwLy4vbm9kZV9tb2R1bGVzL2lyb24td2ViY3J5cHRvL2Rpc3QvaW5kZXguanM/NjUwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMudHNcbnZhciBhbHBoYWJldEJ5RW5jb2RpbmcgPSB7fTtcbnZhciBhbHBoYWJldEJ5VmFsdWUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9KTtcbmZvciAobGV0IGkgPSAwLCBzdGFydCA9IFwiQVwiLmNoYXJDb2RlQXQoMCksIGxpbWl0ID0gXCJaXCIuY2hhckNvZGVBdCgwKTsgaSArIHN0YXJ0IDw9IGxpbWl0OyBpKyspIHtcbiAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIHN0YXJ0KTtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaTtcbiAgYWxwaGFiZXRCeVZhbHVlW2ldID0gY2hhcjtcbn1cbmZvciAobGV0IGkgPSAwLCBzdGFydCA9IFwiYVwiLmNoYXJDb2RlQXQoMCksIGxpbWl0ID0gXCJ6XCIuY2hhckNvZGVBdCgwKTsgaSArIHN0YXJ0IDw9IGxpbWl0OyBpKyspIHtcbiAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIHN0YXJ0KTtcbiAgY29uc3QgaW5kZXggPSBpICsgMjY7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGluZGV4O1xuICBhbHBoYWJldEJ5VmFsdWVbaW5kZXhdID0gY2hhcjtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbaS50b1N0cmluZygxMCldID0gaSArIDUyO1xuICBjb25zdCBjaGFyID0gaS50b1N0cmluZygxMCk7XG4gIGNvbnN0IGluZGV4ID0gaSArIDUyO1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpbmRleDtcbiAgYWxwaGFiZXRCeVZhbHVlW2luZGV4XSA9IGNoYXI7XG59XG5hbHBoYWJldEJ5RW5jb2RpbmdbXCItXCJdID0gNjI7XG5hbHBoYWJldEJ5VmFsdWVbNjJdID0gXCItXCI7XG5hbHBoYWJldEJ5RW5jb2RpbmdbXCJfXCJdID0gNjM7XG5hbHBoYWJldEJ5VmFsdWVbNjNdID0gXCJfXCI7XG52YXIgYml0c1BlckxldHRlciA9IDY7XG52YXIgYml0c1BlckJ5dGUgPSA4O1xudmFyIG1heExldHRlclZhbHVlID0gNjM7XG52YXIgc3RyaW5nVG9CdWZmZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59O1xudmFyIGJ1ZmZlclRvU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xufTtcbnZhciBiYXNlNjR1cmxEZWNvZGUgPSAoX2lucHV0KSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gX2lucHV0ICsgXCI9XCIucmVwZWF0KCg0IC0gX2lucHV0Lmxlbmd0aCAlIDQpICUgNCk7XG4gIGxldCB0b3RhbEJ5dGVMZW5ndGggPSBpbnB1dC5sZW5ndGggLyA0ICogMztcbiAgaWYgKGlucHV0LmVuZHNXaXRoKFwiPT1cIikpIHtcbiAgICB0b3RhbEJ5dGVMZW5ndGggLT0gMjtcbiAgfSBlbHNlIGlmIChpbnB1dC5lbmRzV2l0aChcIj1cIikpIHtcbiAgICB0b3RhbEJ5dGVMZW5ndGgtLTtcbiAgfVxuICBjb25zdCBvdXQgPSBuZXcgQXJyYXlCdWZmZXIodG90YWxCeXRlTGVuZ3RoKTtcbiAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBsZXQgYml0TGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBqID0gaSwgbGltaXQgPSBpICsgMzsgaiA8PSBsaW1pdDsgaisrKSB7XG4gICAgICBpZiAoaW5wdXRbal0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJpdHMgPj49IGJpdHNQZXJMZXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShpbnB1dFtqXSBpbiBhbHBoYWJldEJ5RW5jb2RpbmcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgJHtpbnB1dFtqXX0gaW4gYmFzZTY0IHN0cmluZy5gKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzIHw9IGFscGhhYmV0QnlFbmNvZGluZ1tpbnB1dFtqXV0gPDwgKGxpbWl0IC0gaikgKiBiaXRzUGVyTGV0dGVyO1xuICAgICAgICBiaXRMZW5ndGggKz0gYml0c1BlckxldHRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2h1bmtPZmZzZXQgPSBpIC8gNCAqIDM7XG4gICAgYml0cyA+Pj0gYml0TGVuZ3RoICUgYml0c1BlckJ5dGU7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IE1hdGguZmxvb3IoYml0TGVuZ3RoIC8gYml0c1BlckJ5dGUpO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYnl0ZUxlbmd0aDsgaysrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoYnl0ZUxlbmd0aCAtIGsgLSAxKSAqIGJpdHNQZXJCeXRlO1xuICAgICAgZGF0YVZpZXcuc2V0VWludDgoY2h1bmtPZmZzZXQgKyBrLCAoYml0cyAmIDI1NSA8PCBvZmZzZXQpID4+IG9mZnNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShvdXQpO1xufTtcbnZhciBiYXNlNjR1cmxFbmNvZGUgPSAoX2lucHV0KSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gdHlwZW9mIF9pbnB1dCA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvQnVmZmVyKF9pbnB1dCkgOiBfaW5wdXQ7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IE1hdGgubWluKGkgKyAzLCBpbnB1dC5sZW5ndGgpOyBqIDwgbGltaXQ7IGorKykge1xuICAgICAgYml0cyB8PSBpbnB1dFtqXSA8PCAobGltaXQgLSBqIC0gMSkgKiBiaXRzUGVyQnl0ZTtcbiAgICAgIGJpdExlbmd0aCArPSBiaXRzUGVyQnl0ZTtcbiAgICB9XG4gICAgY29uc3QgYml0Q2x1c3RlckNvdW50ID0gTWF0aC5jZWlsKGJpdExlbmd0aCAvIGJpdHNQZXJMZXR0ZXIpO1xuICAgIGJpdHMgPDw9IGJpdENsdXN0ZXJDb3VudCAqIGJpdHNQZXJMZXR0ZXIgLSBiaXRMZW5ndGg7XG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gYml0Q2x1c3RlckNvdW50OyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChiaXRDbHVzdGVyQ291bnQgLSBrKSAqIGJpdHNQZXJMZXR0ZXI7XG4gICAgICBzdHIgKz0gYWxwaGFiZXRCeVZhbHVlWyhiaXRzICYgbWF4TGV0dGVyVmFsdWUgPDwgb2Zmc2V0KSA+PiBvZmZzZXRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgZGVmYXVsdHMgPSB7XG4gIGVuY3J5cHRpb246IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcImFlcy0yNTYtY2JjXCIsIGl0ZXJhdGlvbnM6IDEsIG1pblBhc3N3b3JkbGVuZ3RoOiAzMiB9LFxuICBpbnRlZ3JpdHk6IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcInNoYTI1NlwiLCBpdGVyYXRpb25zOiAxLCBtaW5QYXNzd29yZGxlbmd0aDogMzIgfSxcbiAgdHRsOiAwLFxuICB0aW1lc3RhbXBTa2V3U2VjOiA2MCxcbiAgbG9jYWx0aW1lT2Zmc2V0TXNlYzogMFxufTtcbnZhciBjbG9uZSA9IChvcHRpb25zKSA9PiAoe1xuICAuLi5vcHRpb25zLFxuICBlbmNyeXB0aW9uOiB7IC4uLm9wdGlvbnMuZW5jcnlwdGlvbiB9LFxuICBpbnRlZ3JpdHk6IHsgLi4ub3B0aW9ucy5pbnRlZ3JpdHkgfVxufSk7XG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgXCJhZXMtMTI4LWN0clwiOiB7IGtleUJpdHM6IDEyOCwgaXZCaXRzOiAxMjgsIG5hbWU6IFwiQUVTLUNUUlwiIH0sXG4gIFwiYWVzLTI1Ni1jYmNcIjogeyBrZXlCaXRzOiAyNTYsIGl2Qml0czogMTI4LCBuYW1lOiBcIkFFUy1DQkNcIiB9LFxuICBzaGEyNTY6IHsga2V5Qml0czogMjU2LCBuYW1lOiBcIlNIQS0yNTZcIiB9XG59O1xudmFyIG1hY0Zvcm1hdFZlcnNpb24gPSBcIjJcIjtcbnZhciBtYWNQcmVmaXggPSBcIkZlMjYuMlwiO1xudmFyIHJhbmRvbUJ5dGVzID0gKF9jcnlwdG8sIHNpemUpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xudmFyIHJhbmRvbUJpdHMgPSAoX2NyeXB0bywgYml0cykgPT4ge1xuICBpZiAoYml0cyA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByYW5kb20gYml0cyBjb3VudFwiKTtcbiAgY29uc3QgYnl0ZXMgPSBNYXRoLmNlaWwoYml0cyAvIDgpO1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoX2NyeXB0bywgYnl0ZXMpO1xufTtcbnZhciBwYmtkZjIgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleUxlbmd0aCwgaGFzaCkgPT4ge1xuICBjb25zdCBwYXNzd29yZEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHBhc3N3b3JkKTtcbiAgY29uc3QgaW1wb3J0ZWRLZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgXCJyYXdcIixcbiAgICBwYXNzd29yZEJ1ZmZlcixcbiAgICB7IG5hbWU6IFwiUEJLREYyXCIgfSxcbiAgICBmYWxzZSxcbiAgICBbXCJkZXJpdmVCaXRzXCJdXG4gICk7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihzYWx0KTtcbiAgY29uc3QgcGFyYW1zID0geyBuYW1lOiBcIlBCS0RGMlwiLCBoYXNoLCBzYWx0OiBzYWx0QnVmZmVyLCBpdGVyYXRpb25zIH07XG4gIGNvbnN0IGRlcml2YXRpb24gPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHBhcmFtcywgaW1wb3J0ZWRLZXksIGtleUxlbmd0aCAqIDgpO1xuICByZXR1cm4gZGVyaXZhdGlvbjtcbn07XG52YXIgZ2VuZXJhdGVLZXkgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoIShwYXNzd29yZCA9PSBudWxsID8gdm9pZCAwIDogcGFzc3dvcmQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgb3B0aW9uc1wiKTtcbiAgaWYgKCEob3B0aW9ucy5hbGdvcml0aG0gaW4gYWxnb3JpdGhtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFsZ29yaXRobTogJHtvcHRpb25zLmFsZ29yaXRobX1gKTtcbiAgY29uc3QgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBobWFjID0gKF9hID0gb3B0aW9ucy5obWFjKSAhPSBudWxsID8gX2EgOiBmYWxzZTtcbiAgY29uc3QgaWQgPSBobWFjID8geyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogYWxnb3JpdGhtLm5hbWUgfSA6IHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfTtcbiAgY29uc3QgdXNhZ2UgPSBobWFjID8gW1wic2lnblwiLCBcInZlcmlmeVwiXSA6IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IG9wdGlvbnMubWluUGFzc3dvcmRsZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXNzd29yZCBzdHJpbmcgdG9vIHNob3J0IChtaW4gJHtvcHRpb25zLm1pblBhc3N3b3JkbGVuZ3RofSBjaGFyYWN0ZXJzIHJlcXVpcmVkKWBcbiAgICAgICk7XG4gICAgbGV0IHsgc2FsdCA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzYWx0KSB7XG4gICAgICBjb25zdCB7IHNhbHRCaXRzID0gMCB9ID0gb3B0aW9ucztcbiAgICAgIGlmICghc2FsdEJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2FsdCBhbmQgc2FsdEJpdHMgb3B0aW9uc1wiKTtcbiAgICAgIGNvbnN0IHJhbmRvbVNhbHQgPSByYW5kb21CaXRzKF9jcnlwdG8sIHNhbHRCaXRzKTtcbiAgICAgIHNhbHQgPSBbLi4ubmV3IFVpbnQ4QXJyYXkocmFuZG9tU2FsdCldLm1hcCgoeCkgPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYXdhaXQgcGJrZGYyKFxuICAgICAgX2NyeXB0byxcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgc2FsdCxcbiAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyxcbiAgICAgIGFsZ29yaXRobS5rZXlCaXRzIC8gOCxcbiAgICAgIFwiU0hBLTFcIlxuICAgICk7XG4gICAgY29uc3QgaW1wb3J0ZWRFbmNyeXB0aW9uS2V5ID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJyYXdcIixcbiAgICAgIGRlcml2ZWRLZXksXG4gICAgICBpZCxcbiAgICAgIGZhbHNlLFxuICAgICAgdXNhZ2VcbiAgICApO1xuICAgIHJlc3VsdC5rZXkgPSBpbXBvcnRlZEVuY3J5cHRpb25LZXk7XG4gICAgcmVzdWx0LnNhbHQgPSBzYWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCBhbGdvcml0aG0ua2V5Qml0cyAvIDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYnVmZmVyIChwYXNzd29yZCkgdG9vIHNtYWxsXCIpO1xuICAgIHJlc3VsdC5rZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgcGFzc3dvcmQsIGlkLCBmYWxzZSwgdXNhZ2UpO1xuICAgIHJlc3VsdC5zYWx0ID0gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5pdilcbiAgICByZXN1bHQuaXYgPSBvcHRpb25zLml2O1xuICBlbHNlIGlmIChcIml2Qml0c1wiIGluIGFsZ29yaXRobSlcbiAgICByZXN1bHQuaXYgPSByYW5kb21CaXRzKF9jcnlwdG8sIGFsZ29yaXRobS5pdkJpdHMpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBnZXRFbmNyeXB0UGFyYW1zID0gKGFsZ29yaXRobSwga2V5LCBkYXRhKSA9PiB7XG4gIHJldHVybiBbXG4gICAgYWxnb3JpdGhtID09PSBcImFlcy0xMjgtY3RyXCIgPyB7IG5hbWU6IFwiQUVTLUNUUlwiLCBjb3VudGVyOiBrZXkuaXYsIGxlbmd0aDogMTI4IH0gOiB7IG5hbWU6IFwiQUVTLUNCQ1wiLCBpdjoga2V5Lml2IH0sXG4gICAga2V5LmtleSxcbiAgICB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvQnVmZmVyKGRhdGEpIDogZGF0YVxuICBdO1xufTtcbnZhciBlbmNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuZW5jcnlwdCguLi5nZXRFbmNyeXB0UGFyYW1zKG9wdGlvbnMuYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbiAgcmV0dXJuIHsgZW5jcnlwdGVkOiBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpLCBrZXkgfTtcbn07XG52YXIgZGVjcnlwdCA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleShfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmRlY3J5cHQoLi4uZ2V0RW5jcnlwdFBhcmFtcyhvcHRpb25zLmFsZ29yaXRobSwga2V5LCBkYXRhKSk7XG4gIHJldHVybiBidWZmZXJUb1N0cmluZyhuZXcgVWludDhBcnJheShkZWNyeXB0ZWQpKTtcbn07XG52YXIgaG1hY1dpdGhQYXNzd29yZCA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleShfY3J5cHRvLCBwYXNzd29yZCwgeyAuLi5vcHRpb25zLCBobWFjOiB0cnVlIH0pO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoZGF0YSk7XG4gIGNvbnN0IHNpZ25lZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLnNpZ24oeyBuYW1lOiBcIkhNQUNcIiB9LCBrZXkua2V5LCB0ZXh0QnVmZmVyKTtcbiAgY29uc3QgZGlnZXN0ID0gYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KHNpZ25lZCkpO1xuICByZXR1cm4geyBkaWdlc3QsIHNhbHQ6IGtleS5zYWx0IH07XG59O1xudmFyIG5vcm1hbGl6ZVBhc3N3b3JkID0gKHBhc3N3b3JkKSA9PiB7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgfHwgcGFzc3dvcmQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybiB7IGVuY3J5cHRpb246IHBhc3N3b3JkLCBpbnRlZ3JpdHk6IHBhc3N3b3JkIH07XG4gIGlmIChcInNlY3JldFwiIGluIHBhc3N3b3JkKVxuICAgIHJldHVybiB7IGlkOiBwYXNzd29yZC5pZCwgZW5jcnlwdGlvbjogcGFzc3dvcmQuc2VjcmV0LCBpbnRlZ3JpdHk6IHBhc3N3b3JkLnNlY3JldCB9O1xuICByZXR1cm4geyBpZDogcGFzc3dvcmQuaWQsIGVuY3J5cHRpb246IHBhc3N3b3JkLmVuY3J5cHRpb24sIGludGVncml0eTogcGFzc3dvcmQuaW50ZWdyaXR5IH07XG59O1xudmFyIHNlYWwgPSBhc3luYyAoX2NyeXB0bywgb2JqZWN0LCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIXBhc3N3b3JkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBjb25zdCBvcHRzID0gY2xvbmUob3B0aW9ucyk7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCkgKyAob3B0cy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApO1xuICBjb25zdCBvYmplY3RTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvYmplY3QpO1xuICBjb25zdCBwYXNzID0gbm9ybWFsaXplUGFzc3dvcmQocGFzc3dvcmQpO1xuICBjb25zdCB7IGlkID0gXCJcIiwgZW5jcnlwdGlvbiwgaW50ZWdyaXR5IH0gPSBwYXNzO1xuICBpZiAoaWQgJiYgIS9eXFx3KyQvLnRlc3QoaWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFzc3dvcmQgaWRcIik7XG4gIGNvbnN0IHsgZW5jcnlwdGVkLCBrZXkgfSA9IGF3YWl0IGVuY3J5cHQoX2NyeXB0bywgZW5jcnlwdGlvbiwgb3B0cy5lbmNyeXB0aW9uLCBvYmplY3RTdHJpbmcpO1xuICBjb25zdCBlbmNyeXB0ZWRCNjQgPSBiYXNlNjR1cmxFbmNvZGUobmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkKSk7XG4gIGNvbnN0IGl2ID0gYmFzZTY0dXJsRW5jb2RlKGtleS5pdik7XG4gIGNvbnN0IGV4cGlyYXRpb24gPSBvcHRzLnR0bCA/IG5vdyArIG9wdHMudHRsIDogXCJcIjtcbiAgY29uc3QgbWFjQmFzZVN0cmluZyA9IGAke21hY1ByZWZpeH0qJHtpZH0qJHtrZXkuc2FsdH0qJHtpdn0qJHtlbmNyeXB0ZWRCNjR9KiR7ZXhwaXJhdGlvbn1gO1xuICBjb25zdCBtYWMgPSBhd2FpdCBobWFjV2l0aFBhc3N3b3JkKF9jcnlwdG8sIGludGVncml0eSwgb3B0cy5pbnRlZ3JpdHksIG1hY0Jhc2VTdHJpbmcpO1xuICBjb25zdCBzZWFsZWQgPSBgJHttYWNCYXNlU3RyaW5nfSoke21hYy5zYWx0fSoke21hYy5kaWdlc3R9YDtcbiAgcmV0dXJuIHNlYWxlZDtcbn07XG52YXIgZml4ZWRUaW1lQ29tcGFyaXNvbiA9IChhLCBiKSA9PiB7XG4gIGxldCBtaXNtYXRjaCA9IGEubGVuZ3RoID09PSBiLmxlbmd0aCA/IDAgOiAxO1xuICBpZiAobWlzbWF0Y2gpXG4gICAgYiA9IGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSlcbiAgICBtaXNtYXRjaCB8PSBhLmNoYXJDb2RlQXQoaSkgXiBiLmNoYXJDb2RlQXQoaSk7XG4gIHJldHVybiBtaXNtYXRjaCA9PT0gMDtcbn07XG52YXIgdW5zZWFsID0gYXN5bmMgKF9jcnlwdG8sIHNlYWxlZCwgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFwYXNzd29yZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgY29uc3Qgb3B0cyA9IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcbiAgY29uc3QgcGFydHMgPSBzZWFsZWQuc3BsaXQoXCIqXCIpO1xuICBpZiAocGFydHMubGVuZ3RoICE9PSA4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2Ygc2VhbGVkIGNvbXBvbmVudHNcIik7XG4gIGNvbnN0IHByZWZpeCA9IHBhcnRzWzBdO1xuICBsZXQgcGFzc3dvcmRJZCA9IHBhcnRzWzFdO1xuICBjb25zdCBlbmNyeXB0aW9uU2FsdCA9IHBhcnRzWzJdO1xuICBjb25zdCBlbmNyeXB0aW9uSXYgPSBwYXJ0c1szXTtcbiAgY29uc3QgZW5jcnlwdGVkQjY0ID0gcGFydHNbNF07XG4gIGNvbnN0IGV4cGlyYXRpb24gPSBwYXJ0c1s1XTtcbiAgY29uc3QgaG1hY1NhbHQgPSBwYXJ0c1s2XTtcbiAgY29uc3QgaG1hYyA9IHBhcnRzWzddO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7cHJlZml4fSoke3Bhc3N3b3JkSWR9KiR7ZW5jcnlwdGlvblNhbHR9KiR7ZW5jcnlwdGlvbkl2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGlmIChtYWNQcmVmaXggIT09IHByZWZpeClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBtYWMgcHJlZml4XCIpO1xuICBpZiAoZXhwaXJhdGlvbikge1xuICAgIGlmICghL15cXGQrJC8udGVzdChleHBpcmF0aW9uKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwaXJhdGlvblwiKTtcbiAgICBjb25zdCBleHAgPSBOdW1iZXIucGFyc2VJbnQoZXhwaXJhdGlvbiwgMTApO1xuICAgIGlmIChleHAgPD0gbm93IC0gb3B0cy50aW1lc3RhbXBTa2V3U2VjICogMWUzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwaXJlZCBzZWFsXCIpO1xuICB9XG4gIGxldCBwYXNzID0gXCJcIjtcbiAgcGFzc3dvcmRJZCA9IHBhc3N3b3JkSWQgfHwgXCJkZWZhdWx0XCI7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgfHwgcGFzc3dvcmQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHBhc3MgPSBwYXNzd29yZDtcbiAgZWxzZSBpZiAocGFzc3dvcmRJZCBpbiBwYXNzd29yZCkge1xuICAgIHBhc3MgPSBwYXNzd29yZFtwYXNzd29yZElkXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHBhc3N3b3JkOiAke3Bhc3N3b3JkSWR9YCk7XG4gIH1cbiAgcGFzcyA9IG5vcm1hbGl6ZVBhc3N3b3JkKHBhc3MpO1xuICBjb25zdCBtYWNPcHRpb25zID0gb3B0cy5pbnRlZ3JpdHk7XG4gIG1hY09wdGlvbnMuc2FsdCA9IGhtYWNTYWx0O1xuICBjb25zdCBtYWMgPSBhd2FpdCBobWFjV2l0aFBhc3N3b3JkKF9jcnlwdG8sIHBhc3MuaW50ZWdyaXR5LCBtYWNPcHRpb25zLCBtYWNCYXNlU3RyaW5nKTtcbiAgaWYgKCFmaXhlZFRpbWVDb21wYXJpc29uKG1hYy5kaWdlc3QsIGhtYWMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBobWFjIHZhbHVlXCIpO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBiYXNlNjR1cmxEZWNvZGUoZW5jcnlwdGVkQjY0KTtcbiAgY29uc3QgZGVjcnlwdE9wdGlvbnMgPSBvcHRzLmVuY3J5cHRpb247XG4gIGRlY3J5cHRPcHRpb25zLnNhbHQgPSBlbmNyeXB0aW9uU2FsdDtcbiAgZGVjcnlwdE9wdGlvbnMuaXYgPSBiYXNlNjR1cmxEZWNvZGUoZW5jcnlwdGlvbkl2KTtcbiAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgZGVjcnlwdChfY3J5cHRvLCBwYXNzLmVuY3J5cHRpb24sIGRlY3J5cHRPcHRpb25zLCBlbmNyeXB0ZWQpO1xuICBpZiAoZGVjcnlwdGVkKVxuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY3J5cHRlZCk7XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IHsgYWxnb3JpdGhtcywgYmFzZTY0dXJsRGVjb2RlLCBiYXNlNjR1cmxFbmNvZGUsIGJ1ZmZlclRvU3RyaW5nLCBjbG9uZSwgZGVjcnlwdCwgZGVmYXVsdHMsIGVuY3J5cHQsIGdlbmVyYXRlS2V5LCBobWFjV2l0aFBhc3N3b3JkLCBtYWNGb3JtYXRWZXJzaW9uLCBtYWNQcmVmaXgsIHJhbmRvbUJpdHMsIHNlYWwsIHN0cmluZ1RvQnVmZmVyLCB1bnNlYWwgfTtcbiJdLCJuYW1lcyI6WyJhbHBoYWJldEJ5RW5jb2RpbmciLCJhbHBoYWJldEJ5VmFsdWUiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJpIiwic3RhcnQiLCJjaGFyQ29kZUF0IiwibGltaXQiLCJjaGFyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaW5kZXgiLCJ0b1N0cmluZyIsImJpdHNQZXJMZXR0ZXIiLCJiaXRzUGVyQnl0ZSIsIm1heExldHRlclZhbHVlIiwic3RyaW5nVG9CdWZmZXIiLCJ2YWx1ZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYnVmZmVyVG9TdHJpbmciLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImJhc2U2NHVybERlY29kZSIsIl9pbnB1dCIsImlucHV0IiwicmVwZWF0IiwidG90YWxCeXRlTGVuZ3RoIiwiZW5kc1dpdGgiLCJvdXQiLCJBcnJheUJ1ZmZlciIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJiaXRzIiwiYml0TGVuZ3RoIiwiaiIsIlR5cGVFcnJvciIsImNodW5rT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIk1hdGgiLCJmbG9vciIsImsiLCJvZmZzZXQiLCJzZXRVaW50OCIsIlVpbnQ4QXJyYXkiLCJiYXNlNjR1cmxFbmNvZGUiLCJzdHIiLCJtaW4iLCJiaXRDbHVzdGVyQ291bnQiLCJjZWlsIiwiZGVmYXVsdHMiLCJlbmNyeXB0aW9uIiwic2FsdEJpdHMiLCJhbGdvcml0aG0iLCJpdGVyYXRpb25zIiwibWluUGFzc3dvcmRsZW5ndGgiLCJpbnRlZ3JpdHkiLCJ0dGwiLCJ0aW1lc3RhbXBTa2V3U2VjIiwibG9jYWx0aW1lT2Zmc2V0TXNlYyIsImNsb25lIiwib3B0aW9ucyIsImFsZ29yaXRobXMiLCJrZXlCaXRzIiwiaXZCaXRzIiwibmFtZSIsInNoYTI1NiIsIm1hY0Zvcm1hdFZlcnNpb24iLCJtYWNQcmVmaXgiLCJyYW5kb21CeXRlcyIsIl9jcnlwdG8iLCJzaXplIiwiYnl0ZXMiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CaXRzIiwiRXJyb3IiLCJwYmtkZjIiLCJwYXNzd29yZCIsInNhbHQiLCJrZXlMZW5ndGgiLCJoYXNoIiwicGFzc3dvcmRCdWZmZXIiLCJpbXBvcnRlZEtleSIsInN1YnRsZSIsImltcG9ydEtleSIsInNhbHRCdWZmZXIiLCJwYXJhbXMiLCJkZXJpdmF0aW9uIiwiZGVyaXZlQml0cyIsImdlbmVyYXRlS2V5IiwiX2EiLCJyZXN1bHQiLCJobWFjIiwiaWQiLCJ1c2FnZSIsInJhbmRvbVNhbHQiLCJtYXAiLCJ4IiwicGFkU3RhcnQiLCJqb2luIiwiZGVyaXZlZEtleSIsImltcG9ydGVkRW5jcnlwdGlvbktleSIsImtleSIsIml2IiwiZ2V0RW5jcnlwdFBhcmFtcyIsImRhdGEiLCJjb3VudGVyIiwiZW5jcnlwdCIsImVuY3J5cHRlZCIsImRlY3J5cHQiLCJkZWNyeXB0ZWQiLCJobWFjV2l0aFBhc3N3b3JkIiwidGV4dEJ1ZmZlciIsInNpZ25lZCIsInNpZ24iLCJkaWdlc3QiLCJub3JtYWxpemVQYXNzd29yZCIsInNlY3JldCIsInNlYWwiLCJvYmplY3QiLCJvcHRzIiwibm93IiwiRGF0ZSIsIm9iamVjdFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXNzIiwidGVzdCIsImVuY3J5cHRlZEI2NCIsImV4cGlyYXRpb24iLCJtYWNCYXNlU3RyaW5nIiwibWFjIiwic2VhbGVkIiwiZml4ZWRUaW1lQ29tcGFyaXNvbiIsImEiLCJiIiwibWlzbWF0Y2giLCJ1bnNlYWwiLCJwYXJ0cyIsInNwbGl0IiwicHJlZml4IiwicGFzc3dvcmRJZCIsImVuY3J5cHRpb25TYWx0IiwiZW5jcnlwdGlvbkl2IiwiaG1hY1NhbHQiLCJleHAiLCJOdW1iZXIiLCJwYXJzZUludCIsIm1hY09wdGlvbnMiLCJkZWNyeXB0T3B0aW9ucyIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iron-webcrypto/dist/index.js\n");

/***/ })

};
;